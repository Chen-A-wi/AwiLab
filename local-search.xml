<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模組化必經之路 Composite Builds</title>
    <link href="/202404243075098463/"/>
    <url>/202404243075098463/</url>
    
    <content type="html"><![CDATA[<p>在專案規模日漸增長的情況下，dependencies 的維護管理會隨著專案的複雜性與模組化使得管理越來越艱鉅，因此為解決這個問題 Gradle 7.0 推出了新的 <code>Catalog</code> 協助開發者來以更好的方式去維護管理 dependencies 的版本，且在新版的 IDE 也新增預設 catalog 這個選項了。</p><p>本篇會以兩大主題為主軸 <code>Catalog &amp; Composite Builds</code>，可搭配官方文件一同食用此外也一並附上 Sample Code，未來有機會也可以搭配 Plugin 整合 CI/CD 自動化更新 Dependencies 版本，如果是營運的專案推薦還是手動管理為優，穩定性與風險較為可控。</p><p>為了更進一步優化專案，也示範了複合式建構 (Composite Builds) 的方式來建置專案，幫助了解其中的差異及提升 Build time 的關鍵，讓你在模組化的康莊大道上走得更為愜意。</p><p>當然模組化不是一個必要項目是個選項，但會走到需要優化 build time 這步田地的專案一定也具備相當的規模了，如果是先天不良後天又失調的專案如何在有限資源改善目前狀況變成為非常重要的課題，不然醫美近年也不會這麼夯了。</p><h1 id="Version-Catalog"><a href="#Version-Catalog" class="headerlink" title="Version Catalog"></a>Version Catalog</h1><p>在 BuildSrc 時期我們會寫一個 object 來管理分類 dependencies 版本及類別概念就與現在的 catalog 相似，但少了 IDE support 所以很難看到版本更新提示需要開發者自己注意版本的更迭，當 dependencies 數量一多時會是非常困擾的問題。</p><p>Catalog 很大程度地解決這個問題，IDE 會幫你在 download 時去 check 版本，Group 相當於我們做的分類再搭配 bundles group 來做使用也可以達到我們自定義類別或是寫 extension 來分類的效果，如前言現在 IDE 已經支援 create default 了，但如果是現行專案還是需要 migrate 的來動手實作吧！</p><h2 id="1-Create-catalog-file"><a href="#1-Create-catalog-file" class="headerlink" title="1. Create catalog file"></a>1. Create catalog file</h2><p>首先切到 Project 在這邊我們找到 gradle 這個資料夾，並 create 一個 file 檔名就叫 <code>libs.versions.toml</code>。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714095610/202404243075098463/n3o1yyrh5ycfdhpkke4g.webp" alt="Create catalog"></p><h2 id="2-在Catalog建立區塊"><a href="#2-在Catalog建立區塊" class="headerlink" title="2. 在Catalog建立區塊"></a>2. 在 Catalog 建立區塊</h2><p>在<a href="https://developer.android.com/build/migrate-to-catalogs#learn-more">官方文件</a>上推薦可以先建立 <code>versions</code>、<code>libraries</code>、<code>plugins</code> 這三個區塊，分別可以管理版號、dependencies、與專案層級的 plugins。</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[versions]</span><br><br><span class="hljs-section">[libraries]</span><br><br><span class="hljs-section">[plugins]</span><br></code></pre></td></tr></tbody></table></figure><p>如果想要自定義 group name 也可以，官方推薦的命名樣式是小駝峰命名其中有保留一些關鍵字供系統使用，命名上須多加注意這幾個名字 <code>class, extensions, convention</code> 如果使用到會有問題。</p><p>Dependencies 的命名中間可以使用 <code>- &amp; _ &amp; .</code> 這三個字符去做區別，gradle 會自動轉換成<code>.</code> 所以不影響使用，範例如：compose-bom 👉 compose.bom。命名上需注意避免下列關鍵字 <code>bundles, versions, plugins</code>，可以參照官方原文👇</p><blockquote><p>Some keywords are reserved, so they cannot be used as an alias. Next words cannot be used as an alias:</p><p>extensions<br>class<br>convention</p><p>Additional to that next words cannot be used as a first subgroup of an alias for dependencies (for bundles, versions and plugins this restriction doesn’t apply):</p><p>bundles<br>versions<br>plugins</p><p>So for example for dependencies an alias versions-dependency is not valid, but versionsDependency or dependency-versions are valid.</p><footer><strong>Gradle docs</strong><cite><a href="https://docs.gradle.org/current/userguide/platforms.html">Gradle 8.1.1</a></cite></footer></blockquote><p>Sample toml file 可以如下面撰寫，name style 可以與開發團隊成員一同討論應該是保有相對應的自由度。</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[versions]</span><br><span class="hljs-attr">coreKtx</span> = <span class="hljs-string">"1.10.0"</span><br><span class="hljs-attr">appcompat</span> = <span class="hljs-string">"1.6.1"</span><br><span class="hljs-attr">composeBom</span> = <span class="hljs-string">"2022.10.00"</span><br><span class="hljs-attr">kotlin</span> = <span class="hljs-string">"1.8.20"</span><br><br><br><span class="hljs-section">[libraries]</span><br><span class="hljs-attr">androidx-appcompat</span> = { module = <span class="hljs-string">"androidx.appcompat:appcompat"</span>, version.ref = <span class="hljs-string">"appcompat"</span> }<br><span class="hljs-attr">androidx-core-ktx</span> = { module = <span class="hljs-string">"androidx.core:core-ktx"</span>, version.ref = <span class="hljs-string">"coreKtx"</span> }<br><span class="hljs-attr">compose-bom</span> = { group = <span class="hljs-string">"androidx.compose"</span>, name = <span class="hljs-string">"compose-bom"</span>, version.ref = <span class="hljs-string">"composeBom"</span> }<br><br><span class="hljs-section">[bundles]</span><br><span class="hljs-attr">androidx</span> = [<span class="hljs-string">"androidx-core-ktx"</span>, <span class="hljs-string">"androidx-appcompat"</span>]<br><br><span class="hljs-section">[plugins]</span><br><span class="hljs-attr">jetbrains-kotlin</span> = { id = <span class="hljs-string">"org.jetbrains.kotlin.android"</span>, version.ref = <span class="hljs-string">"kotlin"</span> }<br></code></pre></td></tr></tbody></table></figure><h2 id="3-Setting-file-path"><a href="#3-Setting-file-path" class="headerlink" title="3. Setting file path"></a>3. Setting file path</h2><p>目前 IDE 支援可以省略這步，但如果用舊一點的版本就需要手動去關聯檔案，所以需要在專案 <code>setting.gradle.kts</code> 中指定相對路徑，補上後 sync 即可。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencyResolutionManagement {<br>    repositories {<br>        mavenCentral()<br>    }<br>    versionCatalogs {<br>        create(<span class="hljs-string">"libs"</span>) {<br>            from(files(<span class="hljs-string">"../gradle/libs.versions.toml"</span>))<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="How-to-implementation"><a href="#How-to-implementation" class="headerlink" title="How to implementation?"></a>How to implementation?</h2><p>Gradle 可以參考下方範例來做引用，plugin 使用 alias 來做引用，後續如果自定義 Composite Builds 的 Plugin 也是在下面這個區塊使用 id 來進行引用。</p><p>Dependencies 的部分就依照命名直接引用就好，IDE 也會 CodeCompletion 可以從提示小窗中選擇需要的 dependency，使用上非常方便。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">plugins {<br>    alias(libs.jetbrains.kotlin)<br>}<br><br>dependencies {<br>    implementation(libs.bundles.androidx)<br>    implementation(platform(libs.jetbrains.kotlin.bom))<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="Composite-Builds"><a href="#Composite-Builds" class="headerlink" title="Composite Builds"></a>Composite Builds</h1><p>Composite Builds 看中文有人把它翻作複合式建構，可以把專案想像成一間集團旗下投資了運動、運輸、餐飲等事業，這些事業群撐起了這整個集團的運作，但是今天單獨營運餐飲事業也是可以營運的，每個事業都有一定程度的相依但耦合度有沒有這麼高。</p><p>這就是 Composite Builds 的概念，也可以看到官網一開頭就寫了這句話 <code>A composite build is a build that includes other builds.</code> 如果還是有點難理解可以看看下面這張架構圖。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714117387/202404243075098463/x73g9ghuukqiuuh5oezc.webp"></p><p>可以看到 my-app &amp; my-utils 是 build 在 my-composite 這個專案裡面，但又自成一個方圓具備 build 及 settings 的 gradle 檔案，所以如果有需要獨立修改成一個專案是可行的。</p><h2 id="Composite-Builds-VS-BuildSrc"><a href="#Composite-Builds-VS-BuildSrc" class="headerlink" title="Composite Builds VS BuildSrc"></a>Composite Builds VS BuildSrc</h2><p>實作 Composing build 之前，可能有看過 buildSrc 在 Gradle 執行時會自動編譯 buildSrc 裡的程式碼，可以將共用程式碼抽取到 buildSrc 內部，後續只要引用該檔案即可有興趣的話可以看我的 <a href="https://medium.com/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-sofware-engineer-survival-guide/how-to-migrate-kotlin-dsl-b857c153526d">Medium</a>，因為篇幅關係這邊就不多做贅述。</p><p>回歸正題，為什麼拋棄 BuildSrc ??</p><p>可以從官方文件看出一些端倪，文中附上了備註意思就是雖然便於進行維護管理但只要有小更動就會 rebuild 整個專案，如果有需求時可以不要 rebuild 提升開發效率只是別忘了要定期去 rebuild 專案。</p><blockquote><p>A change in buildSrc causes the whole project to become out-of-date. Thus, when making small incremental changes, the –no-rebuild command-line option is often helpful to get faster feedback. Remember to run a full build regularly or at least when you’re done, though.</p><footer><strong>Use buildSrc to abstract imperative logic</strong><cite><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources">Gradle 8.1.1</a></cite></footer></blockquote><p>此外 Jose Raska 分享了 buildSrc 需注意的一些要點，要點大意如下。</p><blockquote><ul><li>dependency 更新會 rebuild 整個專案。</li><li>cache 失效，不管是 Local build cache 還是 Remote Gradle cache。</li><li>剩下作者提及的 <code>Iteration speed is slow</code> 有點不太知道要如何翻譯，但我這邊理解是重複 build 的速度很慢如果理解有誤也歡迎留言。</li></ul><footer><strong>Josef Raska</strong><cite><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources">Stop using Gradle buildSrc Use composite builds instead</a></cite></footer></blockquote><p>與 buildSrc 的不同在於 Composing build 是個別獨立的 module 每個都具備完整的 build gradle 並使用 include 方式來去組合一整個專案，所以如<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro">官方</a>所述可以根據需求獨立或是合併各個 module 這也造就了這兩種 build type 先天體質上的差異。</p><h2 id="Create-include-build-module"><a href="#Create-include-build-module" class="headerlink" title="Create include build module"></a>Create include build module</h2><p>先點選右上角的小齒輪在 Menu 中選擇 Project Structure ，並在 Modules 中選擇 “+” 新增一個 Module 名稱可以隨自己喜好去修改，範例中是使用 plugins 來作為 Module Name，步驟可以跟著下方圖示。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1."></a>Step 1.</h3><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714351361/202404243075098463/jci28erordhelerrhyeq.webp" alt="Open setting menu"></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2."></a>Step 2.</h3><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714351627/202404243075098463/f136lm9pnzx2cmdijgf1.webp" alt="Project structure"></p><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3."></a>Step 3.</h3><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714351834/202404243075098463/jakyquup1rudciqatxn8.webp" alt="Create new module"></p><p>到這邊 Gradle sync 完就告了個小段落，最後在該 Module create 一個 <span class="label label-info"> settings.gradle.kts</span> 的檔案即可。<br><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714352093/202404243075098463/tbuutjikagi5e4ofsqoj.webp" alt="Create module setting file"></p><h2 id="Module-gradle"><a href="#Module-gradle" class="headerlink" title="Module gradle"></a>Module gradle</h2><p>找到 Module 的 build.gradle.kts 加入下方的程式碼基本的設定這樣就可以了，但是我會需要在 Module 寫一些 extension 的東西所以看到 Sample 有加一些 dependencies 正常設定這樣即可。</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">gradle-tools-build</span> = { module = <span class="hljs-string">"com.android.tools.build:gradle"</span>, version.ref = <span class="hljs-string">"8.3.2"</span> }<br><span class="hljs-attr">kotlin-gradle-plugin</span> = { module = <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin"</span>, version.ref = <span class="hljs-string">"1.9.23"</span> }<br></code></pre></td></tr></tbody></table></figure><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">plugins {<br>    `kotlin-dsl`<br>}<br><br>repositories {<br>    google()<br>    mavenCentral()<br>}<br><br>dependencies {<br>    implementation(libs.gradle.tools.build)<br>    implementation(libs.kotlin.gradle.plugin)<br>    implementation(files(libs.javaClass.superclass.protectionDomain.codeSource.location))<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Module-settings-gradle"><a href="#Module-settings-gradle" class="headerlink" title="Module settings gradle"></a>Module settings gradle</h2><p>Settings 的檔案是關聯 catalog 的，如果是新版 IDE 的話我記得不加這段依舊是可以吃到這個 toml 的檔案的。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencyResolutionManagement {<br>    repositories {<br>        mavenCentral()<br>    }<br>    versionCatalogs {<br>        create(<span class="hljs-string">"libs"</span>) {<br>            from(files(<span class="hljs-string">"../gradle/libs.versions.toml"</span>))<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Gradle-extension"><a href="#Gradle-extension" class="headerlink" title="Gradle extension"></a>Gradle extension</h2><p>因為 kotlinOptions 這個 function 蠻常被使用的所以就寫成 extension 的形式，方便之後在 Plugin class 呼叫。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CommonExtension<span class="hljs-type">&lt;*, *, *, *, *, *&gt;</span>.<span class="hljs-title">kotlinOptions</span><span class="hljs-params">(block: <span class="hljs-type">KotlinJvmOptions</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {<br>  (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> ExtensionAware).extensions.configure(<span class="hljs-string">"kotlinOptions"</span>, block)<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Plugin-class"><a href="#Plugin-class" class="headerlink" title="Plugin class"></a>Plugin class</h2><p>這部分算是 composing build 的核心，在這邊可以定義 plugins、defaultConfig 或是 dependencies 等，可以視情況需求寫一個共用的 plugin 未來開發上也可以省去很大一部分共用的程式碼，也可以避免有沒有修改到的問題。</p><p>後續各個 module 引用即可，接著來看看大框架如下透過 project target 去加入相關設定，需要注意的是 project extension 並沒有 kotlinOptions 所以在這邊必須 import 先前所寫的 CommonExtension，另一個是 configure 的 extension type 也會因應 modules 是 library 或是 application 有所不同。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibCommonPlugin</span> : <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; {<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(target: <span class="hljs-type">Project</span>)</span></span> {<br>        with(target) {<br>          <span class="hljs-comment">// plugins</span><br>            <br>            extensions.configure&lt;ApplicationExtension&gt; {<br>                <span class="hljs-comment">// android config</span><br>            }<br><br>          <span class="hljs-comment">// dependencies</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>這三個區塊怎麼寫呢？下面就簡單提一下可以仿照有個概念，細節可以照著 Demo 來去實作。</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>其實跟外面帶入 id 類似，但這邊要注意沒辦法在這邊宣告 <code>com.android.application</code> 跟 <code>com.android.library</code> 必須在外部 gradle 就宣告好這個 pluginDependencies，如果有更好的方法也歡迎告知我。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">plugins.run {<br>    apply(<span class="hljs-string">"org.jetbrains.kotlin.android"</span>)<br>    apply(<span class="hljs-string">"de.mannodermaus.android-junit5"</span>)<br>    apply(<span class="hljs-string">"quality.ktlint"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="Android-Config"><a href="#Android-Config" class="headerlink" title="Android Config"></a>Android Config</h3><p>這邊就與 gradle 中 android config 設定差不多，版號的部分也是共用 object 所以可以看到 Demo 裡有 import 相關的檔案。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.awilab.plugins.Versions<br><br>defaultConfig {<br>    compileSdk = Versions.compileSdk<br>    minSdk = Versions.minSdk<br>    testInstrumentationRunner = <span class="hljs-string">"androidx.test.runner.AndroidJUnitRunner"</span><br>}<br><br>compileOptions {<br>    sourceCompatibility = Versions.jdk<br>    targetCompatibility = Versions.jdk<br>}<br><br>packaging {<br>    resources.excludes.apply {<br>        add(<span class="hljs-string">"META-INF/AL2.0"</span>)<br>        add(<span class="hljs-string">"META-INF/LGPL2.1"</span>)<br>    }<br>}<br><br>kotlinOptions {<br>    jvmTarget = Versions.jdk.toString()<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>這部分就很看個人了，可以寫成 DependencyHandlerScope extension function 或是像我這樣宣告一個 libs 的變數統一在 Catalogs 管理，會這麼選擇的原因是因為好像沒有必要特別再拉一個 extension function，catalog 都提供 group 的方式了，且 IDE 還支援版本檢查。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> libs = the&lt;org.gradle.accessors.dm.LibrariesForLibs&gt;()<br><br>dependencies {<br>    <span class="hljs-string">"implementation"</span>(libs.androidx.appcompat)<br>    <span class="hljs-string">"implementation"</span>(libs.androidx.core)<br>    <span class="hljs-string">"implementation"</span>(libs.androidx.lifecycle.runtime)<br><br><br>    <span class="hljs-comment">//region Junit5</span><br>    <span class="hljs-string">"testImplementation"</span>(libs.test.junit.api)<br>    <span class="hljs-string">"testRuntimeOnly"</span>(libs.test.junit.jupiter.engine)<br>    <span class="hljs-comment">//endregion</span><br><br>    <span class="hljs-string">"testImplementation"</span>(libs.test.truth)<br>    <span class="hljs-string">"testImplementation"</span>(libs.test.junit)<br>    <span class="hljs-string">"testRuntimeOnly"</span>(libs.test.junit.vintage.engine)<br>    <span class="hljs-string">"androidTestImplementation"</span>(libs.test.junit.ext)<br>    <span class="hljs-string">"androidTestImplementation"</span>(libs.test.espresso.core)<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Module-build-gradle"><a href="#Module-build-gradle" class="headerlink" title="Module build gradle"></a>Module build gradle</h2><p>先前寫好了 Plugins class 我們接著要在 module 中的 build gradle 定義好 plugin id 跟 implementationClass 讓 IDE 知道需關聯哪個 Class 後續就可以在專案中加入客製化的 plugin 了。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">gradlePlugin {<br>    plugins {<br>        create(<span class="hljs-string">"AppCommonConfig"</span>) {<br>            id = <span class="hljs-string">"plugins.app-common-config"</span><br>            implementationClass = <span class="hljs-string">"plugins.AppCommonPlugin"</span><br>        }<br>        create(<span class="hljs-string">"Compose"</span>) {<br>            id = <span class="hljs-string">"plugins.compose"</span><br>            implementationClass = <span class="hljs-string">"plugins.ComposePlugin"</span><br>        }<br>        create(<span class="hljs-string">"Ktlint"</span>) {<br>            id = <span class="hljs-string">"quality.ktlint"</span><br>            implementationClass = <span class="hljs-string">"quality.KtlintPlugin"</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Apply-customer-plugin"><a href="#Apply-customer-plugin" class="headerlink" title="Apply customer plugin"></a>Apply customer plugin</h2><p>Sync 完後只要在引用的 modules 宣告 plugins id 即可。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">plugins {<br>    alias(libs.plugins.android.application)<br>    id(<span class="hljs-string">"plugins.app-common-config"</span>)<br>    id(<span class="hljs-string">"plugins.compose"</span>)<br>    id(<span class="hljs-string">"quality.ktlint"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="Gradle-Scan"><a href="#Gradle-Scan" class="headerlink" title="Gradle Scan"></a>Gradle Scan</h1><p>這邊附上 Demo 的 gradle scan，如果要優化總是需要一份報告書作為佐證可以使用下方的 command 來產出這份報告，從報告的 time line 也可以讓人更瞭解初始化的差別。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">./gradlew</span> <span class="hljs-string">--scan</span><br></code></pre></td></tr></tbody></table></figure><ul><li><a href="https://scans.gradle.com/s/p2oj5jhjcimmk/timeline">純 Kotlin DSL</a></li><li><a href="https://scans.gradle.com/s/ek6hefozbzuoe/timeline">Composing build</a></li></ul><p>Demo 因為規模很小，如果換成大專案省下的時間會非常的可觀，這邊就附上目前專案上模組化後的 report time line 體感上就會差很多了。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714012005/202404243075098463/uoctockxctsiwyblvla4.webp" alt="Project report time line"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>複合式建構 (Composite Builds) 和模組化 (Modularization) 從來都不是必要的項目但是卻是專案到一定規模必須做的項目，像是職涯選擇不一定需要接觸過 CI/CD 但成為好的 Team leader 前一定會需要懂，畢竟職能需要資源調度也需要為專案負責。理解哪些工作項目屬於值得花時間的投資項目，畢竟科技始終來自於惰性如何更舒服的上班也是很重要的課題。</p><p>專案成長超過一個閾值就會是一個非常值得的項目，因為小專案複雜度不高進行複合式建構及模組化後編譯速度成效非常的有限，就像本文中 Demo 的專案前後相差 2 秒體感有限。在我重構公司專案前跑一次起碼是 20 分鐘，每次 debug 成本都變得非常昂貴，這時就代表該停下來了像以前 Tim 哥說得一樣，開發上需要設一個停損點～</p><p>隨著模組化的精細度越高專案複雜度也會線性增長，所帶來的開發負擔及門檻也會提高，這個又是另一個值得探討的課題了。感謝看到這邊的各位，希望在某些程度上有所幫助<a href="https://github.com/Chen-A-wi/ComposingBuildSample">範例程式</a>在這邊，下次見！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>Banner Photo by <a href="https://unsplash.com/@ilumire?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Jelleke Vanooteghem</a> on <a href="https://unsplash.com/photos/toddler-playing-with-two-wooden-blocks-Aqd30KmCc3g?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Unsplash</a></li><li><a href="https://docs.gradle.org/current/userguide/platforms.html">Sharing dependency versions between projects</a></li><li><a href="https://developer.android.com/build/migrate-to-catalogs#learn-more">Migrate your build to version catalogs</a></li><li><a href="https://proandroiddev.com/using-version-catalog-on-android-projects-82d88d2f79e5">Using Version Catalog on Android projects</a></li><li><a href="https://proandroiddev.com/stop-using-gradle-buildsrc-use-composite-builds-instead-3c38ac7a2ab3">Stop using Gradle buildSrc. Use composite builds instead</a></li><li><a href="https://dev.to/aldok/how-to-manage-dependencies-between-gradle-modules-4jih">How to manage dependencies between Gradle modules?</a></li><li><a href="https://docs.gradle.org/current/userguide/composite_builds.html">Gradle doc - composite build</a></li><li><a href="https://juejin.cn/post/6844904176250519565">再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度</a></li><li><a href="https://blog.csdn.net/c6E5UlI1N/article/details/129574803">是时候弃用 buildSrc , 使用 Composing builds 加快编译速度了</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Composite Builds</tag>
      
      <tag>BuildSrc</tag>
      
      <tag>模組化</tag>
      
      <tag>Modularization</tag>
      
      <tag>Plugin</tag>
      
      <tag>Kotlin DSL</tag>
      
      <tag>Optimize build time</tag>
      
      <tag>優化建構時間</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub Actions 優雅部署 Hexo</title>
    <link href="/20240320564916095/"/>
    <url>/20240320564916095/</url>
    
    <content type="html"><![CDATA[<p>各位在上一篇學廢了怎麼套用 Hexo 的 theme 及一些工具幫助撰寫 Blog，文章中也有提到怎麼安裝 deploy 的 plugin，想了解可以點<a href="https://awilab.com/202402233632500070/">為 Blog 添點顏色</a>。</p><p>我心目中理想的方案是使用 Obsidian 來整合整個文章的發佈，達到將整理好的筆記推至 Blog 中且在本地端瀏覽起來也方便，但是深入研究之後 Obsidian 要 Push 需要訂閱如果想 sync 的話也需要訂閱加總起來的話價格也非常的可觀，對一個北漂求生的工程屍來說也是一筆負擔，後續會嘗試使用 Notion 應該可以達成理想中的撰寫方式，成功的話再整理成文章記錄下來當然如果有更好的方式也歡迎留言提供。</p><p>本篇會多著墨於自動化部屬可以簡化整個寫作發文的流程也有助於 CI/CD 的學習，希望本章有幫上一點忙。</p><h2 id="Continuous-Deployment"><a href="#Continuous-Deployment" class="headerlink" title="Continuous Deployment"></a>Continuous Deployment</h2><p>Continuous Deployment 縮寫為 CD 中文可以翻作續部署，依照需求可以與持續整合（Continuous integration, CI）配合使用，就是大家口中所述的 CI/CD。本篇實作並沒有整合自動化單元測試，因只有一人撰寫也未走完整的 git flow 在我認知中稱不上完整的 CI，所以會多著墨於 CD 的部分。</p><p>說了這麼多什麼是 Continuous Deployment? <a href="https://www.ibm.com/topics/continuous-deployment">IBM</a> 是這麼解釋的。</p><blockquote><p>Continuous deployment is a strategy in software development where code changes to an application are released automatically into the production environment.</p></blockquote><p>大意就是在軟體開發中自動將更動的程式 Build Release 並提交至 Production 環境中，以本篇的例子就是 Main branch 只要有新 commit GitHub Action 就會自動 Build 一個靜態網頁並推至 gh-pages 這個 Branch。</p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>在 <a href="https://githubuniverse.com/">GitHub Universe 2018</a>，GitHub 發佈了 GitHub Actions 可以透過它實作 CI/CD、分支管理、issue 分類等。</p><p>關於計費<a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions">官網</a>寫每個月有 2000 分鐘 / 500MB 的使用上限，使用分鐘數每個月會重置但是 500MB 的儲存空間是不會重置的。機器分鐘的計算方式如下方表格，每個系統分鐘數是不一樣的如果有必要的話需要對專案的建置時間來去做優化。</p><table><thead><tr><th align="center">系統</th><th align="center">分鐘</th></tr></thead><tbody><tr><td align="center"> Linux</td><td align="center">1</td></tr><tr><td align="center">Windows</td><td align="center">2</td></tr><tr><td align="center">macOS</td><td align="center">10</td></tr></tbody></table><p>本篇是用 ubuntu 的 OS 就是 Linux，所以分鐘數不用倍數計算。</p><h2 id="GitHub-deploy-key"><a href="#GitHub-deploy-key" class="headerlink" title="GitHub deploy key"></a>GitHub deploy key</h2><p>就如同使用 Git GUI 推本地端異動到 Repository 一樣，只是這個情境換到 GitHub 的 Server 而已 Repository 要讀寫第一關一定是認證機制也一樣會需要公私鑰來去認證。</p><h3 id="Generator-Key"><a href="#Generator-Key" class="headerlink" title="Generator Key"></a>Generator Key</h3><ol><li>打開 Terminal 輸入下方的 command，<code>e-mail</code> 的部分可以替換成自己的 mail，接著就一路 Enter 下去。<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ssh-keygen</span> <span class="hljs-string">-t ed25519 -C "e-mail" -f deploy</span><br></code></pre></td></tr></tbody></table></figure></li><li>一般來說 gen 出來的 key 會在<code>.ssh</code> 的資料夾內，如果沒有特別設定路徑會在 <code>User/.ssh</code>，這個資料夾預設是隱藏的可以壓 <code>command + shift + .</code> 就可以看到隱藏的資料夾了，內部有兩個檔案 <code>XXX.pub</code> &amp; <code>XXX</code>，沒有更改檔名預設會是 deploy。<div class="note note-info">            <ul><li>XXX.pub：公鑰</li><li> XXX：私鑰</li></ul>          </div></li></ol><h3 id="設定專案公私鑰"><a href="#設定專案公私鑰" class="headerlink" title="設定專案公私鑰"></a>設定專案公私鑰</h3><h4 id="公鑰"><a href="#公鑰" class="headerlink" title="公鑰"></a>公鑰</h4><div class="note note-info">            <p>Setting &gt; Deploy keys &gt; Add deploy key</p>          </div><p>Title 可以隨個人喜好設定，沒有像 branch 有特別命名方式；Key 就 copy XXX 沒有副檔名的檔案內容。<br><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1711506022/20240320564916095/dbsuhsecjxothzsyce8u.webp" alt="Add deploy key"></p><h4 id="私鑰"><a href="#私鑰" class="headerlink" title="私鑰"></a>私鑰</h4><div class="note note-info">            <p>Setting &gt; Secrets and variables &gt; Actions &gt; New repository secret</p>          </div><p>Title 可以隨個人喜好設定只要 Yaml 內容有寫對的話機器就不會找不到 Key 了。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1711506159/20240320564916095/v3nz73xmz4l0phqehvum.webp" alt="Add repository secret"></p><h2 id="Yaml設定"><a href="#Yaml設定" class="headerlink" title="Yaml設定"></a>Yaml 設定</h2><p>新增 GitHub Action 執行所需的 Yaml 方式有兩種：</p><ol><li>在<code>.github</code> 目錄下方新增 <code>workflows</code> 資料夾，並在裡面加入 <code>deploy.yml</code> 的檔案可以針對所需開發自己需要的 job。</li><li>透過 Web 設定，路徑如 <code>Actions &gt; New workflow &gt; Simple workflow</code> 就會創建一個 yml 並放在相對應路徑中方便許多，可以參考下方圖片步驟。</li></ol><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1711508264/20240320564916095/eamt0czo431wsga49vdk.webp" alt="Step 1. New workflow"></p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1711508499/20240320564916095/dkd879bfpgn1t0ettfb0.webp" alt="Step 2. Create simple workflow"></p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1711508649/20240320564916095/gomia0xnwabytkegyuhx.webp" alt="Step 3. Add Jobs"></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Github action name</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br><br><span class="hljs-comment"># 觸發條件</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># 監聽的Branch，只要有commit就會觸發</span><br><br><span class="hljs-comment"># 變數宣告</span><br><span class="hljs-attr">env:</span><br>  <span class="hljs-attr">GIT_USER:</span> <span class="hljs-string">CHIAN-WEI,</span> <span class="hljs-string">CHEN</span><br>  <span class="hljs-attr">GIT_EMAIL:</span> <span class="hljs-string">google@gmail.com</span><br>  <span class="hljs-attr">DEPLOY_REPO:</span> <span class="hljs-string">CHIAN-WEI,</span> <span class="hljs-string">CHEN/Repository</span> <span class="hljs-string">Name</span><br>  <span class="hljs-attr">DEPLOY_BRANCH:</span> <span class="hljs-string">gh-pages</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">on</span> <span class="hljs-string">node</span> <span class="hljs-string">${{</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">}}</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">${{</span> <span class="hljs-string">matrix.os</span> <span class="hljs-string">}}</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span> <span class="hljs-comment"># 建置任務的容器，有下列選擇：ubuntu-latest, windows-latest, macos-latest</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">os:</span> [ <span class="hljs-string">ubuntu-latest</span> ]<br>        <span class="hljs-attr">node_version:</span> [<span class="hljs-string">'20.x'</span>]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">source</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-comment"># 設定Deploy branch</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">deploy</span> <span class="hljs-string">repo</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">repository:</span> <span class="hljs-string">${{</span> <span class="hljs-string">env.DEPLOY_REPO</span> <span class="hljs-string">}}</span><br>          <span class="hljs-attr">ref:</span> <span class="hljs-string">${{</span> <span class="hljs-string">env.DEPLOY_BRANCH</span> <span class="hljs-string">}}</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">.deploy_git</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">${{</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">}}</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">${{</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">}}</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">${{secrets.HEXO_DEPLOY_PRI}}</span> <span class="hljs-comment"># 須與GitHub上Repository secrets內的secret title一樣</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo "$HEXO_DEPLOY_PRI" &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.name ${{ env.GIT_USER }}</span><br><span class="hljs-string">          git config --global user.email ${{ env.GIT_EMAIL }}</span><br><span class="hljs-string"></span><br>      <span class="hljs-comment"># Hexo環境建置</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">ci</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install -g hexo-cli</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">clean</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">generate</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br></code></pre></td></tr></tbody></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以前撰寫文章總是要經歷四步驟 clean、generate、server 沒問題後還要再 deploy 非常繁瑣，工程師都知道<code>科技始終來自於惰性</code>要讓過程簡化的話一定需要自動化，也讓大家撰寫部落格上更加的輕鬆，CI/CD 也是求職上加分的項目所以學會寫 yaml 也蠻重要的。</p><p>希望本篇文章對你有所幫助，如果有問題或需更正歡迎留言！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Banner Photo by <a href="https://unsplash.com/@phillipglickman?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Phillip Glickman</a> on <a href="https://unsplash.com/photos/green-and-multicolored-robot-figurine-2umO15jsZKM?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Unsplash</a></li><li><a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions">About billing for GitHub Actions</a></li><li><a href="https://www.ibm.com/topics/continuous-deployment">What is continuous deployment?</a></li><li><a href="https://blog.yangjerry.tw/2022/04/19/hexo-github-actions-deploy/">Hexo + GitHub Actions 部屬網站遷移全紀錄</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>GitHub Actions</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Deploy</tag>
      
      <tag>Continuous Deployment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>為 Blog 添點顏色</title>
    <link href="/202402233632500070/"/>
    <url>/202402233632500070/</url>
    
    <content type="html"><![CDATA[<p>到目前為止完成了 Blog 本地端建置，整體看起來非常的素面只達到堪用的程度如果想要增進 UX (User Experience) 的話勢必要做點什麼改變有兩個方案可以選擇，可以自己刻 UI (User Interface) 或是套用主題。</p><p>但選擇使用 Hexo 一定是希望可以降低維護成本所以本篇會以套用主題的方式來改善 UX，好的主題通常都會留有相對應的空間可進行調整，選搭喜歡的設定就有一定程度的客製化，如果想更進一步就需要參考官方文件像是 Next 是在 source &gt; _data &gt; styles.styl 內寫 CSS 即可。</p><p>本篇會以 Fluid 作為主題可透過本文了解到選用 Fluid 的原因、Fluid 的設定、Plugin 及圖床選用等。</p><h2 id="如何挑選主題？"><a href="#如何挑選主題？" class="headerlink" title="如何挑選主題？"></a>如何挑選主題？</h2><p>截至目前為止官方主題共有 404 個有興趣可以至<a href="https://hexo.io/themes/index.html">官網</a>選擇，個人覺得只要符合以下要點即可。</p><ul><li>Theme 的 Repository 有持續維護，可以觀察 Commit 的時間</li><li>有 LiveDemo 且使用上正常（如果連 LiveDemo 或是 Readme 上的圖片都壞掉了，高機率已經沒人維護了）</li><li>首頁與內頁等具有一制性且 UI 簡潔，這部分可以參考 <a href="https://m3.material.io/">Material Design</a></li><li> 各個 plugin 的支援度，以 Next 做舉例就可以看到 <a href="https://github.com/next-theme/awesome-next#live-preview">Readme</a> 內有許多推薦的 Plugins</li></ul><p>綜上述要點原先的首選是 <a href="https://github.com/next-theme/hexo-theme-next?tab=readme-ov-file">Next</a> 這個主題，試用一陣子後感覺首頁設計比較適用於全文字的設計如果坎入圖片的話會讓整體的排版有說不上來的不協調感，想要修正就需要更改主題的程式碼，後續只要主題更新就需針對新版本再做一次修正大大增加了維護成本。</p><p>後續尋找的過程中無意間看到 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> 符合我想要的 Material Design 且首頁文章列表加入圖片也不會顯得非常突兀整體上非常合適便選擇了它。</p><h2 id="Fluid設定"><a href="#Fluid設定" class="headerlink" title="Fluid設定"></a>Fluid 設定</h2><ol><li><p>最簡單的方式，現在安裝的 Hexo 版本都是 5.0.0 以上了，所以可以透過 npm 直接安裝後續有更新 theme 也會方便許多。</p>  <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">npm</span> <span class="hljs-string">install --save hexo-theme-fluid</span><br></code></pre></td></tr></tbody></table></figure><p>  如果有高度客製化需求的話建議把 theme clone 到本地的 repository。如果熟悉 git 可以把主題獨立一個 repository 使用 submodules 的方式掛接回原專案主要有兩個原因，可以確保撰寫文章的 repository 的獨立性，theme 有更新時 pull submodule 就會更新 reset 也方便，另一個是抽換 theme 也可以做到無痛抽換只需更換 submodules 的連結與 sha 即可 maintain 上相對單純。</p></li><li><p>在根目錄下創建<code>_config.fluid.yml</code> 的檔案，接著去 copy &amp; paste 官網中的設定檔 theme 主要會以這個 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">yml 檔</a>為主，可以依據個人喜好搭配<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">官方配置指南</a>來去做調整。</p></li></ol><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1710251247/202402233632500070/sx5gkovjjinpfb9hwvsn.webp" alt="_config.fluid.yml"></p><h2 id="Plugin推薦"><a href="#Plugin推薦" class="headerlink" title="Plugin推薦"></a>Plugin 推薦</h2><p>這裡必裝 2 個 Plugin 如下列。</p><ul><li><p><a href="https://github.com/vinta/pangu.js">hexo-pangu</a>：<br>主要是在中、英文、數字之間補上空白如果是純中、英文需求可以省略，但工程師為了準確敘述這個概念時常中英夾雜，這個 Plugin 可以提高文章的閱讀體驗。</p>  <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">npm</span> <span class="hljs-string">install pangu --save</span><br></code></pre></td></tr></tbody></table></figure><p>使用方式是在<code>_config.yml</code> 內補上下面的設定。</p>  <figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># https://github.com/vinta/pangu.js</span><br><span class="hljs-comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span><br><span class="hljs-attr">pangu:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">field:</span> <span class="hljs-string">post</span> <span class="hljs-comment"># site/post</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>：<br>推送到 github repository 需要，未來也須使用這個 plugin 與 github action 來做 CD (Continuous Deployment)。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">npm</span> <span class="hljs-string">install hexo-deployer-git --save</span><br></code></pre></td></tr></tbody></table></figure><p>設定<code>_config.yml</code> 內 Deploy 細節。</p><ul><li>type: Deploy 模式</li><li> repo: Repository 連結</li><li> branch: 想推上去的分支，<code>如果是使用github action來deploy，branch就需使用gh-pages</code><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#troubleshooting-publishing-from-a-branch">詳情請看我</a></li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repo:</span> <span class="hljs-string">Repository</span> <span class="hljs-string">clone</span> <span class="hljs-string">web</span> <span class="hljs-string">url</span> <span class="hljs-string">or</span> <span class="hljs-string">ssh</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></tbody></table></figure><p>最後照先前的順序再多加個 deploy 即可 clean &gt; generate &gt; deploy。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="網站圖示設定"><a href="#網站圖示設定" class="headerlink" title="網站圖示設定"></a>網站圖示設定</h2><p>使用 Browser 時一定會發現分頁上有一個小 icon，如果沒有的話可能會是出現地球的 default icon。在這邊推薦知名的 Favicon 產生器 <a href="https://favicon.io/">Favicon.io</a>，支援 <code>text &gt; ico</code>, <code>png &gt; ico</code>, <code>emoji &gt; ico</code> 使用上已經符合大多數情境且是免費的，這邊以 text &gt; ico 來做舉例。</p><ol><li>選擇轉換的類型，這邊以 <code>text &gt; ico</code> 做舉例。</li></ol><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1710302230/202402233632500070/jszjbix5m9jtzbx0xlaz.webp" alt="Favicon Generate"></p><ol start="2"><li>Preview 可以預覽 icon 的畫面，下面可以依照自身喜好去更改背景顏色、自行、字體、字體大小、背景圖案等，調整完畢後可以點選右側的 <code>Download</code>。</li></ol><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1710313413/202402233632500070/nbr3hcoymy7h2dldtxrw.webp" alt="Setup Favicon"></p><ol start="3"><li>下載後會有一個 zip 檔，解壓縮後會得到下列圖片可以選擇所需放入 theme 取用的資料夾內並在 theme 的 yml 檔裡指定路徑，以 Fluid 舉例就是在<code>_config.fluid.yml</code> 內指定 Favicon 路徑。</li></ol><ul><li>android-chrome-192x192.png</li><li>android-chrome-512x512.png</li><li>apple-touch-icon.png</li><li>favicon-16x16.png</li><li>favicon-32x32.png</li><li>favicon.ico</li><li>site.webmanifest</li></ul><h2 id="圖床選擇"><a href="#圖床選擇" class="headerlink" title="圖床選擇"></a>圖床選擇</h2><p>技術部落格一定會有圖片搭配解說，怎麼處理圖片存取便是很重要的課題，直覺上一定是放在 Repository 裡即可，這麼做會產生兩個問題。</p><ol><li>網頁顯示上的效能問題：<br> 如果檔案格式沒有調整好的話頁面的 Loading 也會變得緩慢，因為網頁的檔案變得非常肥大，除非針對圖片去預載。</li><li>Github Repository 存放大小限制：<br>在靜態網頁上如果是放在 Repository 內又沒針對檔案格式去做調整的話，大概沒多久就會達到官方建議的上限 5 GB。</li></ol><p>要解決這個問題就需要圖床，存放圖片的地方有些人會上傳到 <code>imgur</code> 可以拿到 Url 但這有個問題，官方明訂禁止把 imgur 當作圖床因此圖片在這個平台可以存活的時間不可控，圖片解析度也會大大打折。</p><p>這裡推薦另一個方案，可以使用 <a href="https://cloudinary.com/">Cloudinary</a> 免費就有 25GB 的空間，如果圖片有轉檔處理過之後大小一定會比起 PNG, JPG 小上許多，可以將圖片轉成 Google 新出的圖片格式 webp 大部分的瀏覽器都支援。Cloudinary 除了圖片以外，也支援影片這算是圖床上比較少見的，因為影片佔用的空間相對較大處理上也比較麻煩。</p><p>使用上也非常簡單註冊好後點選 <code>Media Explorer</code> 內建就有圖庫了，想要上傳自己的圖片也可以點選右上角 <code>upload</code>，可以點圖片 copy 左下角的 <code>Original URL</code> 並依照 Markdown 的語法貼上連結即可。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1710342574/202402233632500070/zsqdqmaemczyf1vmfrdf.webp" alt="Upload"></p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1710342565/202402233632500070/uyfoxea0wacrz9pjxeib.webp" alt="Original URL"></p><p>另一個重點是免費版就可以知道各圖片的使用報告，對於改善寫作選圖等也是非常有幫助的。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1714005872/202402233632500070/antszrrt6buvp7oe74nm.webp" alt="Cloudinary report"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>到目前為止已經建立好 Blog 的環境，套用好賞心悅目的主題以及設計了 Blog 的 icon，從前幾篇至目前為止都還沒進入 Domain 就可以知道前期的準備蠻久的方方面面都得自己處理。相對過程中一定也會遇到問題，但這投資是划算的可以自己優化掌控方向也是一大樂趣。希望大家至目前為止開發順利閱讀完也有些收穫，如果有任何問題也歡迎留言，下篇文章見拉！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Banner Photo by <a href="https://unsplash.com/@8moments?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Simon Berger</a> on <a href="https://unsplash.com/photos/landscape-photography-of-mountains-twukN12EN7c?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Unsplash</a></li><li><a href="https://hackmd.io/@Heidi-Liu/note-hexo-github">如何使用 Hexo + GitHub Pages 架設個人網誌</a></li><li><a href="https://free.com.tw/favicon-io/">Favicon.io 最強大的網站圖示產生器，可線上文字製作或以圖片轉換</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部落格建置</tag>
      
      <tag>Blog</tag>
      
      <tag>Github Page</tag>
      
      <tag>Hexo</tag>
      
      <tag>部落格主題</tag>
      
      <tag>Theme</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog 輕鬆建</title>
    <link href="/202402012108647692/"/>
    <url>/202402012108647692/</url>
    
    <content type="html"><![CDATA[<p>單純寫文章記錄的話選擇非常的多，不管是 HackMD、Medium 都是非常不錯的選擇，像 HackMD 可以用 Markdown 來編寫對於習慣 Markdown 的我來說可以無痛轉移。</p><p>Medium 則是在我自架 Blog 前就使用了，主打以文章作為社群媒介我滿喜歡這個 idea，前期有非常強大的 SEO 可以大大提高文章的能見度，可惜後續調整了 SEO 整個改爛了，也能理解為了營利推廣訂閱會員方案，但目前的推銷方式已經多到讓人厭惡的地步了，也時常因沒有訂閱會員就無法閱讀熱門文章。</p><p>思考後像是 Medium、HackMD 那些都依賴於第三方平台如果哪天像是無名小站一樣漸漸式微的話，當營運方維護費用已經高於盈利絕對會選擇關閉，便得出自架是唯一選擇的結論接著便是怎麼達成這個目的？於是踏上這條不歸路。</p><h2 id="Github-Page選擇？"><a href="#Github-Page選擇？" class="headerlink" title="Github Page選擇？"></a>Github Page 選擇？</h2><p>建置 Github Page 選擇百百種，可以藉由下方的條列選項來評估想使用哪種靜態頁面來做開發，如果以原生來說的話 Github 本身是支援 Jekyll 的，簡單方便的話可以直接套用 Jekyll 的主題即可。以上這些工具全都是開源工具，目的只是為了快速產出靜態網站且使維護上更為容易，依據需求選擇最適合你的方式即可。</p><h3 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h3><p>Jekyll 是由 Ruby Gem 所組成的 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Jekyll安裝](https://www.jekyll.com.cn/docs/installation/#requirements)">[1]</span></a></sup>，RubyGems 是 Ruby 的 Plugin 管理器由此可知基底是 Ruby。</p><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><ul><li>從 Medium 移植過來很方便，力推 ZhgChgLi 所製作的 Plugin</li><li>Github 爸爸原生支援</li><li>因為存在非常久了，所以教學文件及資源非常豐富</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li>隨著時間的推移內容較多時，編譯的過時會變得非常慢，這是 Ruby 先天語言的特性</li><li> Jekyll 有段時間沒有更新了</li></ul><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 是基於 Node.js 所開發的，編譯速度也是三者中居於中位原開發者實測 54 篇文章大概可以在 2 秒內跑完，有興趣的朋友可以去朝聖開發者的文章 <a href="https://zespia.me/blog/2012/10/11/hexo-debut/">Hexo 颯爽登場！</a>。</p><h4 id="優點-1"><a href="#優點-1" class="headerlink" title="優點"></a>優點</h4><ul><li>主題非常的多，截至目前為止有 404 個<a href="https://hexo.io/themes/">主題</a>，相較於 Jekyll 或是 Hugo 多非常的多</li><li>套件支援也非常豐富多元</li><li> Hexo 開發討論區大多來自中國，中文化程度與資源相較於 Jekyll 與 Hugo 更為多元</li><li>自帶主題，架設好馬上就可以使用了</li></ul><h4 id="缺點-1"><a href="#缺點-1" class="headerlink" title="缺點"></a>缺點</h4><ul><li>對非中文語系的人來說會討論區較不直覺一些，但這些翻譯都能解決</li></ul><h3 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h3><p>Hugo 是基於 Go 語言所開發的，編譯速度是三者之最官網也是直接宣傳 <a href="https://gohugo.io/">The world’s fastest framework for building websites</a>，對於熟悉 Go 的朋友這個是你的最佳選擇。</p><h4 id="優點-2"><a href="#優點-2" class="headerlink" title="優點"></a>優點</h4><ul><li>三者中最快的，每頁的建置速度不超過 1ms，建置一個 Blog 不會超過 1 秒鐘</li><li>官網也宣稱轉出來後的頁面是純靜態頁面</li></ul><h4 id="缺點-2"><a href="#缺點-2" class="headerlink" title="缺點"></a>缺點</h4><ul><li>主題的選擇相對應 Hexo 較少，但個人認為較 Jekyll 新潮一些</li></ul><h2 id="如何使用Hexo產出靜態頁？"><a href="#如何使用Hexo產出靜態頁？" class="headerlink" title="如何使用Hexo產出靜態頁？"></a>如何使用 Hexo 產出靜態頁？</h2><p>在開始之前要先準備好前置準備，就是 Node.js 與 Git Node.js 是 Hexo 產出靜態網站所需的環境，Git 則是推上 Github 所需要的。歐！還有一個 Github 帳戶。</p><h3 id="前置準備"><a href="#前置準備" class="headerlink" title="前置準備"></a>前置準備</h3><ol><li>如果是 Mac 用戶且裝好了 Homebrew，那直接輸入下方指令👇。沒有的話可以<a href="https://nodejs.org/en/download/current">點我</a>去下載安裝 Node.js，完成後可以輸入 <code>node -v</code> 確認下版號，如果有出來的話代表安裝成功。</li></ol><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brew</span> <span class="hljs-string">install node</span><br></code></pre></td></tr></tbody></table></figure><div class="note note-info">            <p>這裡需要注意 <a href="https://hexo.io/zh-cn/docs/index.html#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6">Hexo 與 node 相對應的版本</a>，別裝錯了。</p>          </div><ol start="2"><li>接著再安裝 Git，輸入下方指令👇。沒有的話可以參考<a href="https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8">官網</a>來安裝，這裡就不多做贅述了，完成後可以輸入 <code>git -v</code> 確認下版號，如果有出來的話代表安裝成功。</li></ol><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brew</span> <span class="hljs-string">install git</span><br></code></pre></td></tr></tbody></table></figure><h3 id="安裝Hexo"><a href="#安裝Hexo" class="headerlink" title="安裝Hexo"></a>安裝 Hexo</h3><p>npm 安裝完後一樣可以確認一下版本順便確認是否安裝成功。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">npm</span> <span class="hljs-string">install hexo-cli -g</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707095598/202402012108647692/yh2yscv9n5hykqw9rzxi.webp" alt="Hexo版本"></p><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化 Hexo</h3><p>先移動到想放 Blog 的資料夾根目錄中，像我想放在 SideProject 裡就先移動至這層資料夾內。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707044173/202402012108647692/mhufwy5bw8gfzsolgl5n.webp" alt="CD至根目錄"></p><p>接著初始化，Hexo 本身會建立好資料夾並安裝在裡面，<span class="label label-primary">這邊需要注意的是安裝 Hexo 的資料夾必須是空的，所以建議可以不用先創好直接使用 command 創立</span>。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">init '資料夾名稱'</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707044288/202402012108647692/atinwqrgpahnbdtatnhw.webp" alt="初始化Hexo"></p><h3 id="安裝Hexo所需Plugin"><a href="#安裝Hexo所需Plugin" class="headerlink" title="安裝Hexo所需Plugin"></a>安裝 Hexo 所需 Plugin</h3><p>先 <code>cd</code> 進我們創建的資料夾內容中，可以使用 tree 這個套件去看資料夾內部的結構，沒有的話可以 <code>brew install tree</code>，我們只是簡單確認所以只進到第一層級應該會如下圖所顯示。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707095215/202402012108647692/a5e0a8tzfgvyduihkeyl.webp" alt="Blog資料夾樹狀圖"></p><p>如果要全顯示的話可以輸入下方的 command，或是<a href="https://blog.csdn.net/zhuyunier/article/details/119837816">參考這篇文章</a>選擇所需的 command。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tree</span> <span class="hljs-string">-N</span><br></code></pre></td></tr></tbody></table></figure><p>確認好資料一樣後可以安裝所需的 plugin 了，Hexo 會依據 package-lock.json<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[package-lock.json的作用](https://yenkos.github.io/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%80%E4%B9%88package-lock.json%20_/)">[2]</span></a></sup> 來去做 plugin 的版本管理也是依據它來安裝。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">npm</span> <span class="hljs-string">install</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707096604/202402012108647692/blj0czqvxjhvmfkmfi80.webp" alt="npm install"></p><div class="note note-info">            <p>注意如果有兩部以上的電腦想要同步 plugin 的話，可以直接刪掉 <code>node_modules</code> 這個資料夾，再 <code>npm install</code> 就會自動依照 json 檔來安裝其他電腦裡的 plugin 了，前提是有 push json 檔案至 Git 中。</p>          </div><h3 id="Build-Hexo-in-local"><a href="#Build-Hexo-in-local" class="headerlink" title="Build Hexo in local"></a>Build Hexo in local</h3><p>完成上述步驟之後差幾步就可以在本地端看到靜態頁面了，加油！</p><p>先清除 Hexo 的暫存檔，這邊記得之後重新產出靜態頁面時要先退出 local server 的狀態，看過有網友直接 clean 結果把本地端 public 的資料夾清掉了。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">cl</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707097060/202402012108647692/a0najy5oq127qknfpxhq.webp" alt="Hexo clean"></p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707097176/202402012108647692/tg3injdv4bypx7ric5vc.webp" alt="Hexo generate"></p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">s</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707097266/202402012108647692/w0qgymnla11ivknbuoy0.webp" alt="Hexo server"></p><p>最後可以 copy localhost 或是 command + 滑鼠左鍵即可跳轉到本地端的網頁了，初始畫面應該會像圖中所示，到這邊恭喜成功嘍！！🎉</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1707097457/202402012108647692/b4gq89xg3ypulgh9kvff.webp" alt="Local web"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>Blog 的前期準備其實蠻花時間的，各個方面全都要自己來如果需要大量客製化的話，可能就需要把主題拉下來接著去修改裡面的 css 內容等，就會需要懂程式語言畢竟需要自行維護可客製化的內容，路途上一定會有些顛簸及坑坑洞洞的，克服後一定會有所成場的！</p><p>我也會記錄下我做了哪些更動或是安裝了哪些 Plugin 從利用 Github Action 來自動化 deploy、Domain 設定、SEO 等，希望是採小章節短文章的形式避免一次太快跟不上，如果有興趣的朋友可以跟著建置一個屬於自己的 Blog，如果有任何問題也歡迎留言提問。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Banner Photo by <a href="https://unsplash.com/@saj_shafique?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Saj Shafique</a> on <a href="https://unsplash.com/photos/silhouette-of-crane-during-sunset-jCJpn7zlyCo?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Unsplash</a></li><li><a href="https://raychiutw.github.io/2019/Static-Site-Generator-Comparison/">靜態網站產生器大比拚</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jekyll.com.cn/docs/installation/#requirements">Jekyll 安裝</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://yenkos.github.io/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%80%E4%B9%88package-lock.json%20_/">package-lock.json 的作用</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部落格建置</tag>
      
      <tag>Blog</tag>
      
      <tag>Github Page</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>為什麼寫 Blog?</title>
    <link href="/202401263323969910/"/>
    <url>/202401263323969910/</url>
    
    <content type="html"><![CDATA[<p>文章斷斷續續也寫了有 6 年的時間，一路從 GitBook、Medium 寫到 Hexo 在這之中也獲得了一些體悟。</p><p>今年！決定抽時間出來整理文章筆記，期望以淺顯易動的方式來解說觀念或是我理解的想法，當然如果直接說結果的話，我非常非常推薦寫技術部落格好處多多文章中也會一一細數。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>會有寫技術部落格這個念頭當初是想要有技術交流的想法，如果有人留言那就代表有機會以不同的角度來去看這個問題，對於問題的理解也會有更深程度的了解。</p><p>另一方面寫技術部落格就等於在寫一篇屬於你自己的筆記也是消化吸收的好時機，必須學會怎麼解釋它的概念才算是某種程度上的理解。</p><p>因為工程師一定是團隊開發溝通就佔了很重要的一部分，解釋使對方理解也是溝通中非常重要的一環，寫文章是刻意練習的一種方式，練習如何去闡述這個觀點或是概念。</p><h1 id="自我提問"><a href="#自我提問" class="headerlink" title="自我提問"></a>自我提問</h1><p>在動手之前一定會有許多內心裡的聲音，像是我寫的文章會有人看嗎？我寫的內容會不會太淺？內容以及我的理解是正確的嗎？這些我也曾經問過我自己，我來一一解答。</p><h3 id="我寫的文章有人看嗎？"><a href="#我寫的文章有人看嗎？" class="headerlink" title="我寫的文章有人看嗎？"></a>我寫的文章有人看嗎？</h3><p>首先只要寫的內容不是空洞無用的文章都一定有人看，所以只要確保文章品質即可。這邊可以看下我先前的 Medium 的閱讀統計圖表，文章至目前為止還是有人在閱讀的，況且你產生了這方面的疑問一定也有人有一樣的疑問所以不用擔心沒有人看。</p><p><img src="https://res.cloudinary.com/deu7aohfe/image/upload/v1706577575/202401263323969910/a72bs-obsd1_x5cqby.webp" alt="Medium 統計表"></p><h3 id="我寫的內容會不會太淺？"><a href="#我寫的內容會不會太淺？" class="headerlink" title="我寫的內容會不會太淺？"></a>我寫的內容會不會太淺？</h3><p>其實可以省去這個想法，當初去聽 Android<br>Taipei 時彥彬有說過不用擔心你演講的內容太淺，每個工程師一定都經歷過各種階段。像是我第一篇的文章居然就是簡單的 HashMap，如果就本科生來說這就是上課就會教的內容基本中的基本，但對轉職的人來說這是個非常新鮮且需要的知識，不是嗎？</p><p>所以只要在文章有正確的傳遞知識的前提下，不用想太多放手的下去寫絕對沒問題的。</p><h3 id="我寫的內容及理解是正確的嗎？"><a href="#我寫的內容及理解是正確的嗎？" class="headerlink" title="我寫的內容及理解是正確的嗎？"></a>我寫的內容及理解是正確的嗎？</h3><p>這應該是最不用擔心的事情，只要寫的文章參考上有超過 1 篇也有經過驗證的話，那傳遞的內容及理解絕對是正確的，不然怎麼重現該目的？該擔心的是對方是否理解你的理解，如何傳達才是該擔心的地方。</p><h1 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h1><p>其實在撰寫中會慢慢發現其中的好處及附帶價值。</p><ul><li>涉略更廣的技術：<ul><li>像是想要架設一個靜態的頁面，就了解到 Hugo, Hexo,<br>Jekyll 可以協助生成一個靜態頁面，為了讓自架網站的 SEO 可以更前面可能會去學 sitemap 的優化，為了讓網站可以自動 deploy 去學習怎麼寫 yaml 檔讓 GithubAction 執行等。</li></ul></li><li>對於技術的理解更熟悉更深入：<ul><li>當學習撰寫成文章闡述觀點及概念時，一定會學著搜尋文章理解各個作者想解釋的內容並且加以佐證以證明自己的觀點，在這樣的一個過程中就會有更深入的認識與理解；在實作上面為了應證這個過程一定會想辦法重現，或是盡可能詳加的紀錄解釋，在這過程中也增加對這門技術熟練程度。</li></ul></li><li>建立自己的學習字典：<ul><li>學習後免不了會忘記，當這個時候翻閱自己的筆記一定是最快的方式，可以讓自己依照以前的流程及思路來去重拾這段記憶，也能為先前的筆記添加遺漏的部分。</li></ul></li><li>練習表達能力：<ul><li>在寫文章的過程中必須去學著闡述這個概念及觀點，在這些反覆思考的過程可以建立該概念解釋的 SOP，對表達能力的提升也是一大助力。</li></ul></li></ul><h1 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h1><p>有優點必定有缺點，缺點就是曠日費時。一篇文章的產出需要經歷草稿、潤稿、校正、資料收集等過程，每一步都需要時間也都需要自己來，品質上的拿捏也是非常重要的，不能為了發文數量而省去了文章品質。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>在動手敲鍵盤之前我想了很久，最後決定寫這篇文章作為這個 Blog 的開頭，因為皮樂寫的<a href="https://hiraku.dev/2021/08/6584/">「寫十年部落格和技術文章的心得」</a><br>影響我深遠且我非常認同皮樂的觀點。</p><p>開始之前不用想太多，給自己揹上這麼多的枷鎖，放鬆心情寫產出絕對更好，以前我也逼自己每個月必須有篇技術文章的產出，後續發現這樣的方式雖然可以最大化的提升成長效率，但就長久來說絕對不是權宜之計。</p><p>在開發上也會因為內化了這些知識，之後再進行延伸也會非常的快速，最終的目的不是證明技術會多少、實力多堅強、開發技巧多華麗，而是在寫好文章後每篇讀者都可以像 code<br>review 一樣審視文章，既有收穫又可以在交流上學到各自缺少的東西。</p><p>相互的增長絕對比自己學習來的效率更好，這也是我推廣大家一起寫技術 Blog 的原因，歡迎一起加入或是留言一起討論疑難雜症。🙂</p>]]></content>
    
    
    <categories>
      
      <category>心靈雜炊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>心靈雜炊</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
